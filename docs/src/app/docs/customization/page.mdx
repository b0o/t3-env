export const metadata = {
  title: "Customization",
  description:
    "Learn how to customize the library to suit your needs by overriding the default behaviors.",
};

# Customization

Below are some examples of how you can customize the behavior of the library. The default values are shown in the snippets below.

## Skipping validation

<Callout type="warning">

Skipping validation is not encouraged and will lead to your types and runtime values being out of sync. It is available to let you opt out of validation during linting (or similar), or if you're building with Docker and not all environment variables are present when building the image.

</Callout>

```ts title="src/env.ts"
import { createEnv } from "@t3-oss/env-core";

export const env = createEnv({
  // ...
  // Tell the library to skip validation if condition is true.
  skipValidation: false,
});
```

## Overriding the default error handler

```ts title="src/env.ts"
import { createEnv } from "@t3-oss/env-core";

export const env = createEnv({
  // ...
  // Called when the schema validation fails.
  onValidationError: (error: ZodError) => {
    console.error(
      "❌ Invalid environment variables:",
      error.flatten().fieldErrors
    );
    throw new Error("Invalid environment variables");
  },
  // Called when server variables are accessed on the client.
  onInvalidAccess: (variable: string) => {
    throw new Error(
      "❌ Attempted to access a server-side environment variable on the client"
    );
  },
});
```

## Tell when we're in a server context

```ts title="src/env.ts"
import { createEnv } from "@t3-oss/env-core";

export const env = createEnv({
  // ...
  // Tell the library when we're in a server context.
  isServer: typeof window === "undefined",
});
```

## Extending Other Envs

In some case, different parts of your application may depend on different environment variables. This is especially common in monorepos. Using the `extends` property, you can extend another `t3-env` instance with additional variables:

```ts title="packages/env/baseEnv.ts"
import { createEnv } from "@t3-oss/env-core";

export const env = createEnv({
  shared: {
    DEBUG: z.enum(["true", "false"]).transform((value) => value === "true"),
  },
  server: {
    NODE_ENV: z.enum(["development", "production"]),
  },
});
```

```ts title="packages/db/src/env.ts"
import { createEnv } from "@t3-oss/env-core";
import { env as baseEnv } from "my-monorepo/env/baseEnv";

export const env = createEnv({
  extends: baseEnv,
  server: {
    DB_HOST: z.string(),
    DB_PORT: z.number(),
  },
});

// Access variables from the extended env just like you would otherwise:
if (env.DEBUG) {
  console.log(`NODE_ENV: ${env.NODE_ENV}, DB_HOST: ${env.DB_HOST}`);
}
```

<Callout type="warning">

The extending env does not inherit any of the other env's options, such as `clientPrefix`, `emptyStringAsUndefined`, `runtimeEnv`, etc. You need to define these separately in each env.

</Callout>
